# Ch1
## 习题
1. 借助基本几何作图操作描述一个算法过程,实现"过直线外一点作其平行线"功能.  

2. **海岛算经** 讨论了如下遥测海岛高度的问题:
    > "今有望海岛,立两表...".

    刘徽所给出的解法是:  
    > "以表高..."  

    a) 该算法原理是什么?  
    b) 以伪代码描述该算法过程.  
    c) 该算法借助了哪些计算工具?

3. 试分别举出实力说明,在对包含n个元素的序列做起泡排序的过程中,可能发生以下情况:  
    a) 任何元素都无需移动(即内循环一轮即可终止算法)  
    b) 某元素会一度朝着远离最终位置方向(即逆向)移动  
    c) 某元素的初始位置与其最终位置相邻,甚至已经处于最终位置,确需要参与n-1次交换  
    d) 所有元素都需要参与n-1次交换  

4. 对n个整数的排序,能否保证在最坏情况下仍可在少于$O(n)$时间内完成?为什么?

5. 随着问题输入规模不断扩大,同一算法所需时间并非总单调递增.试举例说明,随着输入规模的扩大,同一算法所需的计算时间可能上下波动.

6. 一台速度为1G flops的电脑上使用教材中代码1.1中的bubblesort1A()算法,大致需要多长时间才能完成对全国人口记录队排序.

7. 试用C++语言描述一个包含循环、分支、子函数调用,甚至递归结构队算法,并具有常数的整体复杂度.  

8. 试证明,在用对数函数界定渐进复杂度时,常底数的具体取值无所谓.

9.  试证明,对于任何 $\epsilon\gt0$,都有$\log n=O(n^{\epsilon})$

10. 试证明,在大O记号的意义下:  
    a) 等差级数之和与其中最大一项的平方同阶  
    b) 等比级数之和与其中最大一项同阶  

11. 若$f(n)=O(n^2)$且$g(n)=O(n)$,则以下结论是否正确:  
    a) $f(n)+g(n)=O(n^2)$  
    b) $f(n)\div g(n)=O(n)$  
    c) $g(n)=O(f(n))$  
    d) $f(n)*g(n)=O(n^3)$

12. 改进教材代码1.2中countOnes()算法,使得时间复杂度降至:  
    a) $O(countOnes(n))$,线性正比与1的实际数目  
    b) $O(\log_2W)$,$W=O(\log_2n)$为整数的位宽  

13. 实现教材代码1.4中power2BF_I()算法队递归版,要求时间复杂度保持为$O(n)=O(2^r)$  

14. 实现教材代码1.8中power2()算法队迭代版,要求时间复杂度保持为$O(\log)=O(r)$

15. 考察最大元素问题:从n个整数中找出最大者.  
    a) 试分别采用迭代和递归两种模式设计算法,在线性时间内解决该问题  
    b) 用C++语言实现你的算法,并分析他们的复杂度

16. 考察如下问题:设S为一组共n个正整数,其总和为2m,判断是否可将S划分为两个不相交的子集,且各自总和均为m?美国总统选举即是该问题的一个具体实例:
    > 若有两位候选人参选,并争夺n=51个选举人团(50个州和1个特区)的共计2m=538张选举人票,是否可能因两人恰好各得m=269张,而不得不重新选举?

    a) 试设计并实现一个对应的算法,并分析其时间复杂度  
    b) 若没有其它(诸如限定整数取值范围等)附加条件,该问题可否在多项是时间内求解?  

17. 试证明,若每个递归实例仅需使用常数规模队空间,则递归算法所需的空间总是将线性正比于最大的递归深度.

18. 试采用递推方程法,分析教材代码1.5中线性递归版sum()算法队空间复杂度.

19. 考察如教材代码1.12所示的二分递归版fib(n)算法,试证明:  
    a) 对任一整数 $1\le k\le n$ ,形如fib(k)的递归实例,在算法执行过程中都会先后重复出现fib(n-k+1)次  
    b) 该算法的时间复杂度为指数量级  
    c) 该算法队最大递归深度为$O(n)$  
    d) 该算法具有线性的空间复杂度  

20. 考察Fibonacci数的计算  
    a) 试证明,任意算法哪怕只是直接打印输出fib(n),也至少需要$\Omega(n)$的时间  
    b) 试参考教材代码1.8中power2()算法设计一个算法,在$O(logn)$时间计算出fib(n)  
    c) 以上结论是否矛盾?为什么?  

21. 考察fib()算法的二分递归版、线性递归版和迭代版。
    a) 分别编译这些算法,针对n=64实际运行并测试对比  
    b) 三者的运行速度有何差别?为什么?  

22. 参照教材代码1.14中迭代版fibI()算法,实现支持如下接口队Fib类  
    ```C++
    class Fib{  
    public:  
        Fib(int n);  
        int get();  
        int next();  
        int prev();  
    }
    ```

23. 法国数学家Edouard Lucas于1883提出的Hanoi塔问题,可以描述如下:
    > 有n个中心带孔的圆盘贯穿在直立于地面的一根柱子上...

    试将上述转运过程描述为递归形式,并进而实现一个递归算法.

24. 略

25. 九章算数记载的"中华更相减损术"可以快速计算正整数a和b队最大公约数,过程如下:
    > 令p=1

26. 试设计并实现一个就地的算法shift(int A[], int n, int k), 在$O(n)$时间内将数组A[0, n)中的元素整体循环左移k位,例如,数组A[] = {1, 2, 3, 4, 5, 6}经shift(A, 6, 2)后, 有A[] = {3, 4, 5, 6, 1, 2}

27. 试实现一个递归算法,对任意非负整数m和n,计算以下Ackermann函数值:
    $$Ackermann(m, n) = \begin{cases}
    n+1 &(m=0) \\
    Ackermann(m - 1, 1) &(m>0, n=0)\\
    Ackermann(m-1, Ackermann(m,n-1)) &(m>0, n>0)        
    \end{cases}$$
    对于每一(m,n)组合,这个算法是否必然终止?

28. 考察所谓咖啡罐游戏(Coffee Can Game): 在咖啡罐中放有n颗黑豆与m颗白豆,每次取出两颗,若同色,则扔掉它们；若异色,则扔掉黑豆,放回白豆.  
    a) 试证明,该游戏必然终止(当罐中仅剩一颗豆子时)  
    b) 对于哪些(n, m)的组合,最后剩下的必是白豆?

29. 序列Hailstone(n)是从n开始,按照以下规则依次生成的一组自然数:  
    $$Hailstone(n)=\begin{cases}
    \lbrace 1\rbrace &(n=1) \\
    \lbrace n\rbrace \cup {Hailstone(n/2)} &(n为偶数) \\
    \lbrace n\rbrace \cup Hailstone(3n+1) &(n为奇数)
    \end{cases}
    $$
    比如: Hailstone(7) = {7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1}  
    试编写一个非递归程序,计算Hailstone(n)的长度hailstone(n).

30. 在分析并界定其渐进复杂度时,迭代式算法往往体现为级数求和的形式,递归式算法则更多地体现为递推方程的形式.针对这两类主要的分析技巧,参考文献[7](Concrete Mathematics)做了精辟的讲解和归纳,试研读其中的相关章节.

31. 试针对教材代码1.7中的reverse()算法和代码1.8中的power2()算法,运用递归跟踪法分析其时间复杂度.

32. 若假定机器字长无限,移位操作只需单位时间,递归不会溢出,且rand()为理想的随机数发生器.试分析以下函数F(n),并以大O记号的形式确定其渐进复杂度的紧上界.  
    01
    ``` C
    void F(int n){
        for(int i=0; i<n; i++)
        for(int j=0; j<n; j++);
    }
    ```  
    02
    ```C
    void F(int n){
        for(int i=0; i<n; i++)
        for(int j=i; j<n; j++);
    }
    ```
    03
    ```C
    void F(int n){
        for(int i=0; i<n; i++)
        for(int j=0; j<i; j+=2013);
    }
    ```
    04
    ```C
    void F(int n){
        for(int i=0; i<n/2; i++)
        for(int j=i; j<n; j++);
    }
    ```
    05
    ```C
    void F(int n){
        for(int i=n/2; i<n; i++)
        for(int j=0; j<n-i; j++);
    }
    ```
    06
    ```C
    void F(int n){
        for(int i=0; i<n; i++)
        for(int j=1; j<n; j<<=1);
    }
    ```
    07
    ```C
    void F(int n){
        for(int i=0; i<n; i++)
        for(int j=1; j<2013; j<<=1);
    }
    ```
    08
    ```C
    void F(int n){
        for(int i=1; i<n; i++) 
        for(int j=0; j<n; j+=1);
    }
    ```
    09
    ```C
    void F(int n){for(int i=0, j=0; i<n; i+=j, j++);}
    ```
    10
    ```C++
    void F(int n){for(int i=1, r=1; i<n; i<<=r, r<<=1);}
    ```
    11
    ```C++
    void F(int n){for(int i=1; i<n; i=1<<i);}
    ```
    12
    ```C++
    int F(int n){return (n>0) ? G(G(n-1)) : 0;}
    int G(int n){return (n>0) ? G(n-1)+2*n-1 : 0;}
    ```
    13
    ```C++
    void F(int n){for(int i=1; i<<n/G(i,0); i++);}
    int G(int n, int k){return (n<1) ? k : G(n-2*k-1, k+1);}
    ```
    14
    ```C++
    int F(int n){return (n>0) ? G(2, F(n-1)) : 1;}
    int G(int n, int m){return (m>0) ? n+G(n, m-1) : 0;}
    ```
    15
    ```C++
    int F(int n){return (n>3) ? F(n>>1) + F(n>>2) : n;}
    ```
    16
    ```C++
    void F(int n){
        for(int i=n; 0<i; i--)
            if(!(rand() % 1))
                for(int j=0; j<n; j++);
    }
    ```